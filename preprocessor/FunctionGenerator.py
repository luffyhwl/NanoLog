# Copyright (c) 2016-2017 Stanford University
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# This script encapsulates all the logic to parse printf-like format strings
# and generate C++ code/files that perform the record/compression/decompression
# routines for log messages using the NanoLog system.

import errno
import json
import os.path
import re

from collections import namedtuple

# Various globals mapping symbolic names to the object/function names in
# the supporting C++ library. This is done so that changes in namespaces don't
# result in large sweeping changes of this file.
RECORD_ENTRY = "Log::UncompressedEntry"
RECORD_PRIMITIVE_FN = "Log::recordPrimitive"

NIBBLE_OBJ = "BufferUtils::TwoNibbles"
LOG_LEVEL_ENUM = "LogLevel"

LOG_LEVEL_GET_FN = "NanoLog::getLogLevel"
ALLOC_FN = "NanoLog::__internal_reserveAlloc"
FINISH_ALLOC_FN = "NanoLog::__internal_finishAlloc"

PACK_FN = "BufferUtils::pack"
UNPACK_FN = "BufferUtils::unpack"

GENERATED_CODE_NAMESPACE = "GeneratedFunctions"

# This class assigns unique identifiers to unique printf-like format strings,
# generates C++ code to record/compress/decompress the printf-like statements
# in the NanoLog system, and maintains these mappings between multiple
# invocations of the preprocessor system.
#
# This class is intended to be used in two stages. In the first stage, the
# preprocessor component shall identify all the log statements in the user
# files and pass them to the FunctionGenerator, which will attempt to collapse
# similar log statements and return code needed to record the dynamic log
# statement arguments for the preprocessor to inject. The first stage can be
# performed piece-meal since this script maintains state by outputting
# intermediate metadata files to be combined in the second stage. This feature
# is useful for both parallel and partial rebuilds.
#
# In the second stage, after all the user files are processed and compiled,
# the metadata files can be aggregated and passed to this script to output the
# final C++ code required for the compression and decompression of the log
# statements in the runtime library. This stage should be the last step
# before compiling the runtime library and linking it with user code.
class FunctionGenerator(object):

    # Constructor for FunctionGenerator
    def __init__(self):
        # Map of all NANO_LOG statements encountered by this instance of
        # FunctionGenerator. There should be exactly one entry per NANO_LOG
        # in the user sources as each entry is indexed by its format string and
        # the filename/line number of where it occurred. It is pre-populated
        # with an invalid entry to demonstrate the structure of the map
        #
        ### Design Decision ### We uniquely identify log messages by their
        # format strings and filename:linenum so that we can embed more static
        # information (i.e. filename:linenum) at the expense of more entries.
        self.logId2Code = {
            # Mangled form of a NANO_LOG's format string, filename,
            # and line number as generated by generateLogIdStr()
            "__INVALID__INVALID__INVALID__":
                {
                    # printf-like format string in the original NANO_LOG
                    "fmtString"         : "INVALID",

                    # File and line number where NANO_LOG occurred
                    "filename"          : "INVALID.cc",
                    "linenum"           : "-1",

                    # Which g++ preprocessed file did we find this NANO_LOG in?
                    # This can differ from the above in the cases where the
                    # NANO_LOG statement is defined in a header file and it's
                    # include-d in a .cc file. In this case the g++
                    # preprocessor will inline the log statement.
                    "compilationUnit"   : "INVALID.cc",

                    # Complete function definitions for recording, compressing
                    # and decompressing a NANO_LOG statement
                    "recordFnDef"       : "invalidRecord(int arg0) { ... }",
                    "compressFnDef"     : "invalidCompress(...) { ....}",
                    "decompressFnDef"   : "invalidDecompress(...) { ... }",

                    # Function names for the recording, compressing and
                    # decompressing functions above
                    "recordFnName"      : "invalidRecord",
                    "compressFnName"    : "invalidCompress",
                    "decompressFnName"  : "invalidDecompress"
                }
        }

        # Debug data structure that keeps track of the number of parameter
        # combinations (i.e. "%d %d") by mapping the format string to a counter
        self.argLists2Cnt = {}

    # Output the internal state of the FunctionGenerator to a JSON file that
    # can later be aggregated to generate the C++ file that contains the
    # compression and decompression functions.
    #
    # \param filename
    #           file to persist the state to
    def outputMappingFile(self, filename):
        dirname = os.path.dirname(filename)
        if dirname and not os.path.exists(dirname):
            try:
                os.makedirs(dirname)
            except OSError as exc:
                if exc.errno != errno.EEXIST:
                    raise

        with open(filename, 'w') as json_file:
            outputJSON = {
                "argLists2Cnt":self.argLists2Cnt,
                "logId2Code":self.logId2Code
            }

            json_file.write(json.dumps(outputJSON, sort_keys=True,
                                            indent=4, separators=(',', ': ')))

    # Output the C++ header needed by the runtime library to perform the log
    # compression and decompression routines. The file shall contain the
    # following data structures/code:
    #       - Assignment of extern int's that uniquely id the log statements
    #       - A function array mapping id's to compression functions
    #       - A function array mapping id's to decompression functions
    #       - The supporting compression/decompression functions
    #       - The record function that should have been injected (for debugging)
    #
    # \param filename
    #               The C++ file to emit
    @staticmethod
    def outputCompilationFiles(outputFileName="BufferStuffer.h", inputFiles=[]):
        # Merge all the intermediate compilations
        mergedCode = {}
        for filename in inputFiles:
            with open(filename, 'r') as iFile:
                loaded_json = json.load(iFile)
                mergedCode.update(loaded_json["logId2Code"])

        # Output the C++ code. It may be a bit hard to read admist the static
        # C++ code, but all the code immediately before/after a triple quote
        # sections are in the same indention.
        with open(outputFileName, 'w') as oFile:
            oFile.write("""
#ifndef BUFFER_STUFFER
#define BUFFER_STUFFER
#include <xmmintrin.h>

#include "NanoLog.h"
#include "Packer.h"

#include <string>

// Since some of the functions/variables output below are for debugging purposes
// only (i.e. they're not used in their current form), squash all gcc complaints
// about unused variables/functions.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"

/**
 * Describes a log message found in the user sources by the original format
 * string provided, the file where the log message occurred, and the line number
 */
struct LogMetadata {
  const char *fmtString;
  const char *fileName;
  uint32_t lineNumber;
  LogLevel logLevel;
};

// Start an empty namespace to enclose all the record(debug)/compress/decompress
// functions
namespace {
""")
            for logId, code in mergedCode.iteritems():
                if logId == "__INVALID__INVALID__INVALID__":
                    continue

                oFile.write(code["recordFnDef"] + "\n")
                oFile.write(code["compressFnDef"] + "\n")
                oFile.write(code["decompressFnDef"] + "\n")

            oFile.write("""
} // end empty namespace

// Assignment of numerical ids to format NANO_LOG occurrences
""")

            # Here, we take the iteration order as the canonical order
            count = 0
            logId2Metadata = []
            compressFnNameArray = []
            decompressFnNameArray = []
            for logId, code in mergedCode.iteritems():
                if logId == "__INVALID__INVALID__INVALID__":
                    continue

                logId2Metadata.append("{\"%s\", \"%s\", %d, %s}" % (
                    code["fmtString"],
                    code["filename"],
                    code["linenum"],
                    code["logLevel"]
                ))

                oFile.write("extern const int %s = %d; // %s:%d \"%s\"\n" % (
                        generateIdVariableNameFromLogId(logId),
                        count,
                        code["filename"],
                        code["linenum"],
                        code["fmtString"]
                ))
                count += 1

                compressFnNameArray.append(code["compressFnName"])
                decompressFnNameArray.append(code["decompressFnName"])
            oFile.write("""
// Start new namespace for generated ids and code
namespace {namespace} {{

// Map of numerical ids to log message metadata
struct LogMetadata logId2Metadata[{count}] =
{{
    {listOfLogId2Metadata}
}};

// Map of numerical ids to compression functions
ssize_t
(*compressFnArray[{count}]) ({Entry} *re, char* out)
{{
    {listOfCompressFnNames}
}};

// Map of numerical ids to decompression functions
void
(*decompressAndPrintFnArray[{count}]) (const char **in,
                                        FILE *outputFd,
                                        void (*aggFn)(const char*, ...))
{{
    {listOfDecompressionFnNames}
}};

// Total number of logIds. Can be used to bounds check array accesses.
size_t numLogIds = {count};

// Pop the unused gcc warnings
#pragma GCC diagnostic pop

}}; // {namespace}

#endif /* BUFFER_STUFFER */
""".format(count=count,
           Entry=RECORD_ENTRY,
           listOfLogId2Metadata=",\n".join(logId2Metadata),
           listOfCompressFnNames=",\n".join(compressFnNameArray),
           listOfDecompressionFnNames=",\n".join(decompressFnNameArray),
           namespace=GENERATED_CODE_NAMESPACE
))

    # Given a compilation unit via filename, return all the record functions
    # that were generated for that file.
    #
    # \param compilationUnit
    #           filename of compilation unit
    #
    # \return
    #            List of record function definitions related to the compilation
    #            unit
    def getRecordFunctionDefinitionsFor(self, compilationUnit):
        recordFns = []

        for logId, code in self.logId2Code.iteritems():
            if code["compilationUnit"] == compilationUnit:
                recordFns.append(code["recordFnDef"])

        return recordFns

    # Given the format string and the arguments to a log statement, generate
    # the code required to record the dynamic information in the
    # NanoLog system.
    #
    # Note that this function will only return the record function declaration
    # and invocation. The defintion for a compilationUnit can be gotten via
    # getRecordFunctionDefinitionsFor(compilationUnit)
    #
    # \param logLevel
    #           The LogLevel associated with this NANO_LOG statement
    #
    # \param fmtString
    #           C++ printf-like format string for the log message
    #           (note "%n"  is not supported)
    # \param compilationName
    #           C++ file being preprocessed/compiled
    # \param filename
    #           The original file where the log statement occurred. This can
    #           differ from compilationUnit in the cases where log messages
    #           in header files are #include-d/inlined into the compilationUnit
    # \param linenum
    #           The line in the filename where the log statement was found
    #
    # \return
    #           tuple of the record function declaration and invocation.
    #
    # \throws ValueError
    #           If there's is a syntax error in the format string
    def generateLogFunctions(self, logLevel, fmtString, compilationName,
                                    filename, linenum):

        fmtTypes = parseTypesInFmtString(fmtString)
        parameterDeclarationString = "".join([", %s arg%d" % (fmt.type, idx)
                                          for idx, fmt in enumerate(fmtTypes)])

        logId = generateLogIdStr(fmtString, filename, linenum)
        recordFnName = "__syang0__fl" + logId
        recordDeclaration = "void %s(%s level, const char* fmtStr %s)" % (
                    recordFnName, LOG_LEVEL_ENUM, parameterDeclarationString)

        # Keep track of instance metrics
        if parameterDeclarationString in self.argLists2Cnt:
            self.argLists2Cnt[parameterDeclarationString] += 1
        else:
            self.argLists2Cnt[parameterDeclarationString] = 1

        # If we've already generated code for this invocation, don't do it again
        if self.logId2Code.get(logId):
            return (recordDeclaration, recordFnName)

        ###
        # Generate Record function
        ###

        # Create lists identifying which argument indexes are (not) strings
        stringArgIds = [idx for idx, fmt in enumerate(fmtTypes)
                                                    if isStringType(fmt)]
        nonStringArgIds = [idx for idx, fmt in enumerate(fmtTypes)
                                                    if idx not in stringArgIds]

        # Create more usable strings for each list
        strlenDeclarations = []
        for idx in stringArgIds:
            precision = fmtTypes[idx].precision
            strlenToAdd = "size_t str{0}Len = ".format(idx)
            if not precision:
                strlenToAdd += "strlen(arg{0});".format(idx)
            elif precision == '*':
                strlenToAdd += "strnlen(arg{0}, arg{1});".format(idx, idx - 1)
            else:
                strlenToAdd += "strnlen(arg{0}, {1});".format(idx, precision)
            strlenDeclarations.append(strlenToAdd)

        # For these two partial sums, it must end in a '+' character. Also,
        # for stringLenPartialSum, there's a +1 for a NULL character at the end
        stringLenPartialSum = "".join(["str%dLen + 1 + " % (idx)
                                      for idx in stringArgIds])

        nonStringSizeOfPartialSum = "".join(["sizeof(arg%d) + " % idx
                                          for idx in nonStringArgIds])

        # Bytes needed to store the primitive byte lengths
        nibbleByteSizes = (len(nonStringArgIds) + 1)/2

        recordNonStringArgsCode = "".join(["\t%s(buffer, arg%d);\n" % \
                (RECORD_PRIMITIVE_FN, idx) for idx in nonStringArgIds])

        recordStringsArgsCode = ["memcpy(buffer, arg{0}, str{0}Len); "
               "buffer += str{0}Len; *buffer = '\\0'; buffer++;".format(
                                                idx) for idx in stringArgIds]

        # Start Generating the record code
        recordCode = \
"""
inline {function_declaration} {{
    extern const uint32_t {idVariableName};

    if (level > {getLogLevelFn}())
        return;

    {strlen_declaration};
    size_t allocSize = {primitive_size_sum} {strlen_sum} sizeof({entry});
    {entry} *re = reinterpret_cast<{entry}*>({alloc_fn}(allocSize));

    re->fmtId = {idVariableName};
    re->timestamp = PerfUtils::Cycles::rdtsc();
    re->entrySize = static_cast<uint32_t>(allocSize);

    char *buffer = re->argData;

    // Record the non-string arguments
    {recordNonStringArgsCode}

    // Record the strings (if any) at the end of the entry
    {recordStringsArgsCode}

    // Make the entry visible
    {finishAlloc_fn}(allocSize);

    // Prefetch
    /*
    uint64_t numBytes = allocSize + sizeof({entry});
    uint64_t offset = reinterpret_cast<uint64_t>(re) & 0x3fUL;
    const char* p = reinterpret_cast<const char*>(re) - offset;
    for (uint64_t i = 0; i < offset + numBytes; i += 64) {{
        _mm_prefetch(p + i, _MM_HINT_T0);
    }}
    */
}}
""".format(function_declaration = recordDeclaration,
       getLogLevelFn=LOG_LEVEL_GET_FN,
       strlen_declaration = "\r\n\t".join(strlenDeclarations),
       primitive_size_sum = nonStringSizeOfPartialSum,
       strlen_sum = stringLenPartialSum,
       entry = RECORD_ENTRY,
       alloc_fn = ALLOC_FN,
       idVariableName = generateIdVariableNameFromLogId(logId),
       nibble_size = nibbleByteSizes,
       recordNonStringArgsCode = recordNonStringArgsCode,
       recordStringsArgsCode = "\r\n\t".join(recordStringsArgsCode),
       finishAlloc_fn = FINISH_ALLOC_FN
)

        ###
        # Generate compression
        ###

        # Generate code to compress the arguments from a RecordEntry to
        # an output array. Note that the compression runtime code should have
        # handled the metadata, so we don't have to worry about that here

        readBackNonStringArgsCode = ""
        for idx in nonStringArgIds:
            type = fmtTypes[idx].type
            readBackNonStringArgsCode += \
                "\t{type} arg{id} = *reinterpret_cast<{type}*>(args); " \
                "args +=sizeof({type});\n".format(type=type, id=idx)

        packNonStringArgsCode = ""
        for i, idx in enumerate(nonStringArgIds):
            mem = "first" if (i % 2 == 0) else "second"
            arrIndex = i / 2
            packNonStringArgsCode += \
                "\tnib[%d].%s = 0x0f & static_cast<uint8_t>(%s(&out, arg%d));\n" \
                    % (arrIndex, mem, PACK_FN, idx)

        compressFnName = "compressArgs" + logId
        compressionCode = \
"""
inline ssize_t
{compressFnName}({Entry} *re, char* out) {{
    char *originalOutPtr = out;

    // Allocate nibbles
    {Nibble} *nib = reinterpret_cast<{Nibble}*>(out);
    out += {nibbleBytes};

    char *args = re->argData;

    // Read back all the primitives
    {readBackNonStringArgsCode}

    // Pack all the primitives
    {packNonStringArgsCode}

    if ({hasStrings}) {{
        // memcpy all the strings without compression
        size_t stringBytes = re->entrySize - ({sizeofNonStringTypes} 0)
                                            - sizeof({Entry});
        if (stringBytes > 0) {{
            memcpy(out, args, stringBytes);
            out += stringBytes;
        }}
    }}

    return out - originalOutPtr;
}}
""".format(compressFnName=compressFnName,
        Entry=RECORD_ENTRY,
        Nibble=NIBBLE_OBJ,
        nibbleBytes=nibbleByteSizes,
        readBackNonStringArgsCode=readBackNonStringArgsCode,
        packNonStringArgsCode=packNonStringArgsCode,
        sizeofNonStringTypes=nonStringSizeOfPartialSum,
        hasStrings=("true" if stringArgIds else "false")
)

        ###
        # Generate Decompression
        ###

        # Unpack all the non-string arguments with their nibbles
        unpackNonStringArgsCode = ""
        for i, idx in enumerate(nonStringArgIds):
            type = fmtTypes[idx].type
            member = "first" if (i%2 == 0) else "second"

            unpackNonStringArgsCode += "\t%s arg%d = %s<%s>(in, nib[%d].%s);\n" % (
                                        type, idx, UNPACK_FN, type, i/2, member)

        # Read back all the strings
        readbackStringCode = ""
        for idx in stringArgIds:
            type = fmtTypes[idx].type

            readbackStringCode += \
            """
                {type} arg{idx} = *in;
                (*in) += strlen(arg{idx}) + 1; // +1 for null terminator
            """.format(idx=idx, type=type)


        decompressFnName = "decompressPrintArgs" + logId
        decompressionCode = \
"""
inline void
{decompressFnName} (const char **in,
                        FILE *outputFd,
                        void (*aggFn)(const char*, ...)) {{
    {Nibble} nib[{nibbleBytes}];
    memcpy(&nib, (*in), {nibbleBytes});
    (*in) += {nibbleBytes};

    // Unpack all the non-string argments
    {unpackNonStringArgsCode}

    // Find all the strings
    {readbackStringCode}

    const char *fmtString = "{fmtString}";
    const char *filename = "{filename}";
    const int linenum = {linenum};
    const LogLevel logLevel = {logLevel};

    if (outputFd)
        fprintf(outputFd, "{fmtString}" "\\r\\n" {printfArgs});

    if (aggFn)
        (*aggFn)("{fmtString}" {printfArgs});
}}
""".format(decompressFnName=decompressFnName,
        Nibble=NIBBLE_OBJ,
        nibbleBytes=nibbleByteSizes,
        unpackNonStringArgsCode=unpackNonStringArgsCode,
        readbackStringCode=readbackStringCode,
        fmtString=fmtString,
        filename=filename,
        linenum=linenum,
        logLevel=logLevel,
        printfArgs="".join([", arg%d" % i for i, type in enumerate(fmtTypes)])
)

        # All the code has been generated,  save them in our data structure
        code = {
            "fmtString"         : fmtString,
            "filename"          : filename,
            "linenum"           : linenum,
            "logLevel"          : logLevel,
            "compilationUnit"   : compilationName,
            "recordFnDef"       : recordCode,
            "compressFnDef"     : compressionCode,
            "decompressFnDef"   : decompressionCode,
            "recordFnName"      : recordFnName,
            "compressFnName"    : compressFnName,
            "decompressFnName"  : decompressFnName
        }

        self.logId2Code[logId] = code

        return (recordDeclaration, recordFnName)

# Identifies a format specifier's C++ type and precision within a format string.
# The precision can have the value of None, a number, or '*' which indicate,
# respectively, that none was provided, a static number was provided, or
# it's specified in the previous printf argument.
FmtType = namedtuple('FmtType', ['type', 'precision'])

# Given a C++ printf-like format string, identify all the C++ types that
# correspond to the format specifiers in the format string.
#
# Note that the "%n" specifier is not supported in the NanoLog system and
# will cause the following function to throw a ValueError
#
# \param fmtString
#           Printf-like format string such as "number=%d, float=%0.2f"
#
# \return
#           A list of FmtType named tuples indicating (C++ type, precision) Ex:
#           [("int", None), ("const char*", "*"), ("const char*", "4"), ...]
#           Note: a precision of '*' indicates previous element is precision
#
# \throws ValueError
#           Thrown if the format string does not conform to standards
def parseTypesInFmtString(fmtString):
    # This function follows the standard according to the cplusplus reference
    # http://www.cplusplus.com/reference/cstdio/printf/ (9/7/16)

    # These are the set of characters that can serve as specifiers
    signedSet = 'di'
    unsignedSet = 'uoxX'
    floatSet = 'fFeEgGaA'
    integerSet = signedSet + unsignedSet

    # The next while loop scans through the string looking for unescaped "%"
    matches = []
    charIndex = 0
    consecutivePercents = 0
    while charIndex < len(fmtString):
        c = fmtString[charIndex]

        if c == "\\":
            # Skip the next character if there's an escape
            charIndex += 1
        elif c == "%":
            consecutivePercents += 1
            if consecutivePercents % 2 == 1:
                # At this point we should be at a %, so try to regex it
                match = re.match("^%"
                                 "(?P<flags>[-+ #0]+)?"
                                 "(?P<width>[\\d]+|\\*)?"
                                 "(\\.(?P<precision>\\d+|\\*))?"
                                 "(?P<length>hh|h|l|ll|j|z|Z|t|L)?"
                                 "(?P<specifier>[diuoxXfFeEgGaAcspn])",
                                 fmtString[charIndex:])

                if match:
                    matches.append(match)
                elif not re.match("%%", fmtString[charIndex:]):
                    raise ValueError("Unrecognized Format Specifier: \"%s\"" %
                                        fmtString[charIndex:].split()[0])
        else:
            consecutivePercents = 0

        charIndex += 1

    types = []
    for fmt in matches:
        length = fmt.group('length')
        specifier = fmt.group('specifier')
        precision = fmt.group("precision")
        if precision and precision != '*':
            precision = int(float(precision))

        # First, handle the cases where the users specify variable width
        # spacing (i.e. %*d or %*.*lf) requiring an extra argument
        if fmt.group('width') == "*":
            types.append(FmtType("int", None))

        if precision == "*":
            types.append(FmtType("int", None))

        # Handle the most common case of regular integer types first
        if specifier in integerSet:
            type = ""

            if specifier in unsignedSet:
                type += "unsigned "

            if not length:
                type += "int "
            elif length == "hh":
                type = "unsigned char" if type else "signed char"
            elif length == "h":
                type += "short int "
            elif length == "l":
                type += "long int"
            elif length == "ll":
                type += "long long int"
            # Special length modifiers here override the original signed-ness
            elif length == "j":
                if specifier in signedSet:
                    type = "intmax_t"
                else:
                    type = "uintmax_t"
            elif length == "z" or length == "Z":
                type = "size_t"
            elif length == "t":
                type = "ptrdiff_t"
            else:
                raise ValueError("Invalid arguments for format specifier "
                                    + fmt.group())

            types.append(FmtType(type.strip(), precision))

        # Next are doubles
        elif specifier in floatSet:
            if length == 'L':
                types.append(FmtType("long double", precision))
            else:
                types.append(FmtType("double", precision))

        # Finally the special cases
        elif specifier == "p":
            if not length:
                types.append(FmtType("const void*", precision))
            else:
                raise ValueError("Invalid arguments for format specifier "
                                    + fmt.group())
        elif specifier == "s":
            if not length:
                types.append(FmtType("const char*", precision))
            elif length == "l":
                types.append(FmtType("const wchar_t*", precision))
            else:
                raise ValueError("Invalid arguments for format specifier "
                                    + fmt.group())
        elif specifier == "c":
            if not length:
                types.append(FmtType("int", precision))
            elif length == "l":
                types.append(FmtType("wint_t", precision))
            else:
                raise ValueError("Invalid arguments for format specifier "
                                 + fmt.group())
        elif specifier == "n":
            raise ValueError("\"%n\" print specifier not supported in "
                             + fmt.group())

    return types

# Given a C++ type (such as 'int') as identified by parseTypesInFmtString,
# determine whether that type is a string or not.
#
# \param typeStr - Whether a FmtType is a string or not in C/C++ land
def isStringType(typeStr):
    return -1 != typeStr.type.find("char*") or \
           -1 != typeStr.type.find("wchar_t*")

# Helper functions to generate variable names
def generateIdVariableNameFromLogId(logId):
    return "__fmtId" + logId

def generateLogIdStr(fmtString, filename, linenum):
    def encode(string):
        return "".join([c if c.isalnum() else str(ord(c)) for c in string])

    return "__%s__%s__%d__" % (encode(fmtString), encode(filename), linenum)
